% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/autopartial.R
\name{autopartial}
\alias{autopartial}
\title{Automatic partial function application}
\usage{
autopartial(.f, ...)
}
\arguments{
\item{.f}{<\code{\link{closure}} | \code{\link{primitive}}> function to turn into an automatically
partially-applied function.}

\item{...}{optional arguments to be partially applied to \code{.f}.}
}
\value{
A modified version of \code{.f} that will automatically be partially
applied until all of its required arguments have been given.
}
\description{
Construct an \code{autopartial} function; that is, a function that supports
\emph{automatic partial application}.

When a function created by \code{autopartial()} is called,
if all of its required arguments have not been provided, it returns a
modified version of itself that uses the arguments passed to it so far as
defaults. Once all required arguments have been supplied, the function is
evaluated.

\code{autopartial()} can be considered a form of
\href{https://en.wikipedia.org/wiki/Currying}{currying} with respect to
a function's required arguments, but I think \emph{automatic partial application}
gets the idea across more clearly. \code{autopartial()} also has a number of
features, like named arguments and defaults, which are not typically
considered part of the classical definition of currying. See \strong{Details}.
}
\details{
Create an \emph{automatically partially-applied} function by passing it to
\code{autopartial()}. The resulting function can be called repeatedly until
all required arguments (i.e. those that do not have default values
provided in the function definition) have been supplied, then the function is
evaluated and the result returned.

For example, consider the function \code{f}:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{f = function(x, y, z, a = 4) c(x, y, z, a)
f = autopartial(f)
f
#> <autopartial with DEFAULTs>:
#> f = function(x, y, z, a = 4) c(x, y, z, a)
#>   <environment: 0x00000177ea267178>
#> f()
}\if{html}{\out{</div>}}

It can be called as normal:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{f(1, 2, 3)
#> [1] 1 2 3 4
}\if{html}{\out{</div>}}

If all required arguments haven't been supplied yet, the result is a
partially-applied function:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{f(1)
#> <autopartial with DEFAULTs>:
#> f = function(x, y, z, a = 4) c(x, y, z, a)
#>   <environment: 0x00000177ea267178>
#> f(x = 1)
}\if{html}{\out{</div>}}

These invocations can be chained in arbitrary combinations:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{f(1)(2)(3)
#> [1] 1 2 3 4
f(z = 3)(1, 2)
#> [1] 1 2 3 4
f(y = 2, z = 3)(1)
#> [1] 1 2 3 4
f(y = 2)(1)(3)
#> [1] 1 2 3 4
# etc ...
}\if{html}{\out{</div>}}

Positional arguments can be supplied by position or by name. Named arguments
can be supplied anywhere in the sequence; e.g. \code{f(a = 7)(1, 2, 3)} is
equivalent to \code{f(1, 2, 3, a = 7)}.

Arguments supplied in one partial call can be overridden later in the sequence.
For example, \code{f(1)(x = 2)(x = 3)} is equivalent to just \code{f(x = 3)}.

Arguments may also be passed the special value \code{\link[=DEFAULT]{DEFAULT()}}. If \code{\link[=DEFAULT]{DEFAULT()}} is
passed to an argument, its default value (or the most recently-partially-applied
non-\code{\link{DEFAULT}} value) is used instead. For example, \code{f(a = DEFAULT())} is
equivalent to \code{f(a = 4)} (since the default value of \code{a} is \code{4} in the
definition of \code{f}), and \code{f(x = 1)(x = DEFAULT())} is equivalent to \code{f(x = 1)}.
}
\section{Implementation details}{

Great pains are taken to ensure that \code{autopartial} functions act as much as
possible like normal R functions.

The initial definition of an \code{autopartial} function has the same
\code{\link[=formals]{formals()}} as the function it wraps. When it is further partially applied,
the \code{\link[=formals]{formals()}} are updated to reflect the expressions of the modified
arguments. To allow for sequences of applications of positional arguments
(e.g. \code{f(1)(2)(3)}) to be equivalent to a single application (e.g.
\code{f(1, 2, 3)}), positional arguments are moved to the back of the \code{\link[=formals]{formals()}}
list when they are applied.

During partial application, arguments are stored as \code{\link{promise}}s and will not
be evaluated until the underlying function is ultimately called (and even
then, an argument may not be evaluated if that function does not evaluate
the argument in question---just like normal R functions). Thus, non-standard
evaluation constructs like \code{\link[=substitute]{substitute()}} should work correctly within the
underlying function.

\code{\link[=DEFAULT]{DEFAULT()}} values are detected, as much as possible, without evaluating
arguments: a \code{\link[=DEFAULT]{DEFAULT()}} is valid only if it is stored in a symbol passed to
an argument or if \code{DEFAULT()} is passed directly to the argument.

The final function evaluation acts as much as possible like a normal function
evaluation. The underlying function is called from the same environment that
the final \code{autopartial} function is called from, so functions that inspect
their context (e.g. using \code{\link[=parent.frame]{parent.frame()}}) should work correctly. The call
expression associated with the function invocation is also constructed
to reflect all of the partially-applied arguments and the original function
name, so functions that use \code{\link[=sys.call]{sys.call()}} or \code{\link[=match.call]{match.call()}} should also give
nice-looking output.

For example, the \code{\link[=density]{density()}} function, which uses both \code{\link[=substitute]{substitute()}} and
\code{\link[=match.call]{match.call()}} to construct labels for its output, gives identical output
if invoked directly (e.g. \code{density(rnorm(10))}) or via \code{autopartial()}
(e.g. \code{autopartial(density)(rnorm(10))}).

Under the hood, \code{autopartial()} uses \code{\link[=new_autopartial]{new_autopartial()}} to create the
\emph{automatically partially-applied} function, captures intermediate arguments
as \code{\link{promise}}s using \code{\link[=capture_all]{capture_all()}}, and ultimately uses \code{\link[=invoke]{invoke()}}
to call the underlying function.
}

\examples{
# create a custom automatically partially-applied function
f = autopartial(function(x, y, z = 3) (x + y) * z)
f()
f(1)
g = f(y = 2)(z = 4)
g
g(1)

# pass DEFAULT() to optional arguments to use existing values
f(z = DEFAULT())(1, 2)  # uses default z = 3
f(z = 4)(z = DEFAULT())(1, 2)  # uses z = 4

}
\seealso{
Other partial function constructors: 
\code{\link{new_autopartial}()},
\code{\link{partial}()}
}
\concept{partial function constructors}
